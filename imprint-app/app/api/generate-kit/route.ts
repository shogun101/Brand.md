import OpenAI from 'openai';

const MODULE_SECTION_MAPS: Record<string, Array<{ id: string; title: string; description: string }>> = {
  'positioning': [
    { id: 'what-we-do', title: 'What We Do', description: 'plain language company description' },
    { id: 'problem-we-solve', title: 'The Problem We Solve', description: 'the specific pain or gap being addressed' },
    { id: 'who-we-serve', title: 'Who We Serve', description: 'the target customer or audience' },
    { id: 'competitive-landscape', title: 'Competitive Landscape', description: 'how this fits vs existing alternatives' },
    { id: 'positioning-statement', title: 'Positioning Statement', description: 'the synthesized "For X who Y, Brand is Z that W" statement' },
    { id: 'messaging-framework', title: 'Messaging Framework', description: 'key messages for different contexts (website, pitch, social)' },
    { id: 'agent-directives', title: 'Agent Directives', description: 'machine-readable positioning rules for AI agents' },
  ],
  'voice-tone': [
    { id: 'brand-personality', title: 'Brand Personality', description: 'who they are, who they are not' },
    { id: 'tone-by-context', title: 'Tone by Context', description: 'how they sound in different situations (social, support, pitch)' },
    { id: 'formality-spectrum', title: 'Formality Spectrum', description: '1-10 scale with what it means for this brand' },
    { id: 'voice-guardrails', title: 'Voice Guardrails', description: 'always/never rules for brand writing' },
    { id: 'do-dont-examples', title: 'Do / Don\'t Examples', description: 'concrete before/after writing pairs' },
    { id: 'agent-directives', title: 'Agent Directives', description: 'machine-readable voice and tone rules for AI agents' },
  ],
  'persona': [
    { id: 'the-person', title: 'The Person', description: 'vivid profile with name, role, situation, and daily reality' },
    { id: 'pain-points', title: 'Their Pain Points', description: 'numbered list of specific, visceral pains they experience' },
    { id: 'how-they-talk', title: 'How They Talk About This', description: 'their actual language, search queries, phrases they use' },
    { id: 'what-they-use-today', title: 'What They Use Today', description: 'current alternatives and workarounds' },
    { id: 'what-makes-them-act', title: 'What Makes Them Finally Act', description: 'the trigger event or moment that makes them seek a solution' },
    { id: 'agent-directives', title: 'Agent Directives', description: 'machine-readable audience rules for AI agents' },
  ],
  'vision-values': [
    { id: 'vision', title: 'Vision', description: 'one sentence: the world when you have won' },
    { id: 'mission', title: 'Mission', description: 'what the team does every day to get there' },
    { id: 'brand-as-person', title: 'Brand as a Person', description: 'how they look, carry themselves, and talk' },
    { id: 'core-principles', title: 'Core Principles', description: '3-4 numbered values with practical, day-to-day meaning' },
    { id: 'guardrails', title: 'Guardrails', description: 'what this brand would never do' },
    { id: 'brand-promise', title: 'Brand Promise', description: 'the one-line commitment to every customer' },
    { id: 'agent-directives', title: 'Agent Directives', description: 'machine-readable values rules for AI agents' },
  ],
};

const MODULE_TAGLINES: Record<string, string> = {
  'positioning':   'Generated by Imprint. Feed this into any AI agent to align it with your brand positioning.',
  'voice-tone':    'Generated by Imprint. Feed this into any AI agent to make it talk like your brand.',
  'persona':       'Generated by Imprint. Feed this into any AI agent so it knows exactly who your customer is.',
  'vision-values': 'Generated by Imprint. Feed this into any AI agent so it understands what your brand stands for.',
};

export async function POST(req: Request) {
  try {
    const { sections, transcript, moduleKey, agentKey, brandName } = await req.json();

    const client = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY,
    });

    const sectionMap = MODULE_SECTION_MAPS[moduleKey] ?? MODULE_SECTION_MAPS['positioning'];
    const tagline = MODULE_TAGLINES[moduleKey] ?? MODULE_TAGLINES['positioning'];

    const sectionList = sectionMap
      .map((s) => `- \`${s.id}\`: "${s.title}" — ${s.description}`)
      .join('\n');

    const capturedSectionsText = Object.keys(sections).length > 0
      ? JSON.stringify(sections, null, 2)
      : '(none captured during session)';

    const transcriptText = Array.isArray(transcript) && transcript.length > 0
      ? transcript.map((t: { source: string; message: string }) => `[${t.source.toUpperCase()}]: ${t.message}`).join('\n\n')
      : '(no transcript available)';

    const systemPrompt = `You are a world-class brand strategist and AI systems architect.

The user just completed a "${moduleKey}" session for brand "${brandName}" with agent "${agentKey}".
You have their captured sections and full session transcript.

Your job: synthesize this into a complete Brand.md file. This file will be loaded as context into AI agents (Claude, GPT, Cursor, etc.) — it is NOT read by humans. Write for machines.

WRITING STANDARD:
- Every sentence must be a directive or fact an AI agent can act on immediately
- No adjectives without specifics. "fast" → "ships in under 24h". "helpful" → "answers support queries in one message"
- No filler phrases: no "we believe", "we strive", "our mission is", "we are committed to"
- Write in third person about the brand — use the brand name or "they", never "you" or "we"
- Dense and declarative — like a spec doc, not a brand manifesto
- Use the user's ACTUAL words and phrases from the transcript wherever possible

WHEN INPUT IS VAGUE OR THIN:
- Extract the strongest signal from what was said and make it concrete
- If the user said something general, find the most specific interpretation that fits
- If a section was genuinely not discussed at all → write: "[Not covered — needs input]"
- NEVER invent details that were not in the session. NEVER hallucinate.

THE AGENT DIRECTIVES SECTION (most important):
Write this as a strict numbered ruleset. These rules will be injected verbatim into AI agent system prompts. They must be:
- Unambiguous — no room for interpretation
- Testable — an AI can check if it is following the rule
- Immediately usable — no context needed to understand them
Format:
RULE 1: [specific rule]
RULE 2: [specific rule]
...

Generate sections for these specific IDs:
${sectionList}

The tagline for this kit is: "${tagline}"

Output valid JSON only — no markdown, no preamble, no explanation. Just the JSON object.

Output structure:
{
  "kit": {
    "tagline": "${tagline}",
    "sections": [
      {
        "id": "section-slug",
        "title": "Section Title",
        "content": "Full section content — 3-5 sentences, specific, declarative, written for AI agents to read and use directly"
      }
    ],
    "agent_directives": "RULE 1: ...\\nRULE 2: ...\\n(machine-readable rules an AI agent must follow)",
    "retrieval_rules": {
      "website_copy": ["section-id-1", "section-id-2"],
      "social_media": ["section-id-1", "section-id-3"],
      "pitch_deck": ["section-id-1", "section-id-4"],
      "agent_config": ["section-id-1", "section-id-2", "agent-directives"]
    },
    "usage_prompts": [
      "Write a landing page headline using my ${moduleKey} above",
      "Rewrite this copy to match my brand: [paste text]",
      "Does this email match my brand guidelines? [paste text]"
    ]
  }
}`;

    const userPrompt = `## Captured Sections (from live session)
${capturedSectionsText}

## Full Session Transcript
${transcriptText}

Build the complete brand kit now. Use only what was actually discussed. Be specific.`;

    const response = await client.chat.completions.create({
      model: 'gpt-5.2',
      max_completion_tokens: 8192,
      response_format: { type: 'json_object' },
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt },
      ],
    });

    const content = response.choices[0]?.message?.content ?? '{}';
    let parsed: { kit?: unknown };
    try {
      parsed = JSON.parse(content);
    } catch {
      parsed = {};
    }

    return Response.json(parsed);
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Unknown error';
    console.error('[generate-kit] Error:', message);
    return Response.json({ error: message }, { status: 500 });
  }
}
